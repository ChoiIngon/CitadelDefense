// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;

namespace Gamnet
{
	public class StreamSession : Session
	{
		public Gamnet.Buffer recvBuffer = new Gamnet.Buffer();
		public delegate void DelegateRecvHandler(Gamnet.Buffer ms);
		class HandlerContainer
		{
			public System.Timers.Timer timer;
			public DelegateRecvHandler handler;
			public static void Timeout(Session session)
			{
				ErrorEvent evt = new ErrorEvent();
				evt.session = session;
				evt.error = new System.TimeoutException();
				session.eventQueue.Enqueue(evt);
			}
		};
		private Dictionary<int, HandlerContainer> _dictHandler = new Dictionary<int, HandlerContainer>();

		public static int PACKET_HEADER_SIZE = 6;
		public static int PACKET_SIZE_OFFSET = 0;
		public static int MSGID_OFFSET = 2;

		public override void OnConnect () {}
        public override void OnReconnect() {}
		public override void OnClose () {}
		public override void OnError (System.Exception e) {}
		public override void OnReceive(Gamnet.Buffer buf)
		{
            recvBuffer += buf;
			while (recvBuffer.Size() >= PACKET_HEADER_SIZE) {
				ushort packetLength = BitConverter.ToUInt16 (recvBuffer.buffer, recvBuffer.readIndex + PACKET_SIZE_OFFSET);
				if (packetLength > Gamnet.Buffer.BUFFER_SIZE) {					
					throw new Exception (string.Format ("The packet length is greater than the buffer max length."));
				}
				
				if (packetLength > recvBuffer.Size ()) {
					return;
				}

                Gamnet.Buffer tmpBuffer = new Gamnet.Buffer(recvBuffer);
                int msgID = BitConverter.ToInt32(tmpBuffer.buffer, tmpBuffer.readIndex + MSGID_OFFSET);
				if(false == _dictHandler.ContainsKey(msgID))
				{
					ErrorEvent evt = new ErrorEvent();
					evt.session = this;
					evt.error = new System.Collections.Generic.KeyNotFoundException();
					eventQueue.Enqueue(evt);
					return;
				}

				HandlerContainer container = _dictHandler[msgID];
                if (null != container.timer)
                {
                    container.timer.Stop();
                    container.timer.Close();
                }
				tmpBuffer.readIndex += PACKET_HEADER_SIZE;
                try
                {
                    container.handler(tmpBuffer);
                }
                catch (System.Exception) {}

				recvBuffer.readIndex += packetLength;
                recvBuffer = new Gamnet.Buffer(recvBuffer);
			}
		}
		public void RegisterHandler(int msgID, DelegateRecvHandler handler, int timeout = 0)
		{
			HandlerContainer container = new HandlerContainer ();
            if (0 < timeout)
            {
                container.timer = new System.Timers.Timer();
                container.timer.Interval = timeout * 1000;
                container.timer.AutoReset = false;
                container.timer.Elapsed += delegate { HandlerContainer.Timeout(this); };
                container.timer.Start();
            }
			container.handler = handler;
			_dictHandler [msgID] = container;
		}

		public virtual void SendMsg(object msg)
		{
			try
			{
				System.IO.MemoryStream ms = new System.IO.MemoryStream();
                System.Type type = msg.GetType();
				type.GetMethod("Store").Invoke(msg, new object[] { ms });
                System.Reflection.FieldInfo fi = type.GetField("MSG_ID");

                int msgID = (int)fi.GetValue(msg);
    			int dataLength = (int)(type.GetMethod("Size").Invoke(msg, null));
				ushort packetLength = (ushort)(PACKET_HEADER_SIZE + dataLength);
				
				if (packetLength > Gamnet.Buffer.BUFFER_SIZE)
				{
					throw new System.Exception(string.Format("Overflow the send buffer max size : {0}", packetLength));
				}
				
				byte[] buffer = new byte[packetLength];
				byte[] length_buf = BitConverter.GetBytes(packetLength);
				
				buffer[0] = length_buf[0];
				buffer[1] = length_buf[1];
				
				byte[] msgid_buf = BitConverter.GetBytes(msgID);
				
				buffer[2] = msgid_buf[0];
				buffer[3] = msgid_buf[1];
				buffer[4] = msgid_buf[2];
				buffer[5] = msgid_buf[3];
				
				System.Array.Copy(ms.GetBuffer(), 0, buffer, PACKET_HEADER_SIZE, dataLength);
				AsyncSend(buffer);
			}
			catch (System.Exception error)
			{
                Error(error);
                Close();
			}
		}
        public void SendMsg<T>(object msg, DelegateRecvHandler handler, int timeout = 0) where T : new()
        {
            System.Reflection.FieldInfo fi = typeof(T).GetField("MSG_ID");
            int ansMsgID = (int)fi.GetValue(null);
            RegisterHandler(ansMsgID, handler, timeout);
            SendMsg(msg);
        }
	}
}

